This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-27T14:17:28.582Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
Form/
  FormCheckBox.tsx
  FormCheckBoxGroup.tsx
  FormDatePicker.tsx
  FormInput.tsx
  FormRadioGroup.tsx
  FormRange.tsx
  FormSelect.tsx
  interfaces.ts
Table/
  ColumnFilter.tsx
  DebouncedInput.tsx
  GlobalFilter.tsx
  Pagination.tsx
  RowSelectCheckBox.tsx
  Table.tsx
Alert.tsx
Input.tsx
Select.tsx
ToolTip.tsx

================================================================
Repository Files
================================================================

================
File: Form/FormCheckBox.tsx
================
import { Field } from "formik";
import React from "react";
import { Form, InputGroup } from "react-bootstrap";
import ToolTip from "../ToolTip";
import { IFormikFieldProps, IFormProps } from "./interfaces";

/**
 * @author Ankur Mundra on May, 2023
 */

const FormCheckbox: React.FC<IFormProps> = (props) => {
  const { controlId, label, name, disabled, tooltip, tooltipPlacement } = props;

  const displayLabel = tooltip ? (
    <>
      {label}&nbsp;
      <ToolTip id={`${controlId}-tooltip`} info={tooltip} placement={tooltipPlacement} />
    </>
  ) : (
    label
  );

  return (
    <Field name={name}>
      {({ field, form }: IFormikFieldProps) => {
        return (
          <Form.Group controlId={controlId}>
            <InputGroup>
              <Form.Check
                {...field}
                className="mx-md-2"
                type="checkbox"
                disabled={disabled}
                label={displayLabel}
                isInvalid={form.touched[field.name] && form.errors[field.name]}
                feedback={form.errors[field.name]}
              />
              <Form.Control.Feedback type="invalid">
                {form.errors[field.name]}
              </Form.Control.Feedback>
            </InputGroup>
          </Form.Group>
        );
      }}
    </Field>
  );
};

export default FormCheckbox;

================
File: Form/FormCheckBoxGroup.tsx
================
import { Field } from "formik";
import React from "react";
import { Form, InputGroup } from "react-bootstrap";
import ToolTip from "../ToolTip";
import { IFormikFieldProps, IFormPropsWithOption } from "./interfaces";

/**
 * @author Ankur Mundra on May, 2023
 */

const FormCheckboxGroup: React.FC<IFormPropsWithOption> = (props) => {
  const { as, md, controlId, label, name, options, disabled, tooltip, tooltipPlacement } = props;

  const displayLabel = tooltip ? (
    <>
      {label}&nbsp;
      <ToolTip id={`${controlId}-tooltip`} info={tooltip} placement={tooltipPlacement} />
    </>
  ) : (
    label
  );

  return (
    <Field name={name}>
      {({ field, form }: IFormikFieldProps) => (
        <Form.Group as={as} md={md} controlId={controlId}>
          {label && <Form.Label>{displayLabel}</Form.Label>}
          <InputGroup>
            {options.map((option) => (
              <Form.Check
                {...field}
                key={option.value}
                type="checkbox"
                className="mx-md-2"
                label={option.label}
                value={option.value}
                disabled={disabled}
                checked={field.value.includes(option.value)}
                onChange={(e) => {
                  if (e.target.checked) {
                    form.setFieldValue(name, [...field.value, option.value]);
                  } else {
                    form.setFieldValue(
                      name,
                      field.value.filter((value: string) => value !== option.value)
                    );
                  }
                }}
              />
            ))}
          </InputGroup>
        </Form.Group>
      )}
    </Field>
  );
};

export default FormCheckboxGroup;

================
File: Form/FormDatePicker.tsx
================
import { Field } from "formik";
import React from "react";
import { Form } from "react-bootstrap";
import DatePicker from "react-datepicker";
import "react-datepicker/dist/react-datepicker.css";
import { IFormikFieldProps } from "./interfaces";

/**
 * @author Ankur Mundra on May, 2023
 */

interface IFormDatePickerProps {
  controlId: string;
  name: string;
}

const FormDatePicker: React.FC<IFormDatePickerProps> = (props) => {
  const { controlId, name } = props;

  return (
    <Field name={name}>
      {({ field, form }: IFormikFieldProps) => {
        const isValid = !form.errors[field.name];
        const isInvalid = form.touched[field.name] && !isValid;
        return (
          <Form.Group controlId={controlId}>
            <DatePicker
              required
              showTimeSelect
              timeIntervals={60}
              minDate={new Date()}
              selected={field.value || null}
              dateFormat="MMMM d, yyyy h:mm aa"
              placeholderText="Select a Due Date"
              onChange={(val) => form.setFieldValue(field.name, val)}
              className={`form-control ${isInvalid ? "is-invalid" : ""}`}
            />
            <Form.Control.Feedback type="invalid">{form.errors[field.name]}</Form.Control.Feedback>
          </Form.Group>
        );
      }}
    </Field>
  );
};

export default FormDatePicker;

================
File: Form/FormInput.tsx
================
import { Field } from "formik";
import React from "react";
import { Form, InputGroup } from "react-bootstrap";
import ToolTip from "../ToolTip";
import { IFormikFieldProps, IFormProps } from "./interfaces";

/**
 * @author Ankur Mundra on May, 2023
 */

const FormInput: React.FC<IFormProps> = (props) => {
  const {
    name,
    label,
    type,
    controlId,
    tooltip,
    as,
    md,
    disabled,
    inputGroupPrepend,
    inputGroupAppend,
    tooltipPlacement,
  } = props;

  const displayLabel = tooltip ? (
    <>
      {label}&nbsp;
      <ToolTip id={`${controlId}-tooltip`} info={tooltip} placement={tooltipPlacement} />
    </>
  ) : (
    label
  );

  return (
    <Field name={name}>
      {({ field, form }: IFormikFieldProps) => {
        const isValid = !form.errors[field.name];
        const isInvalid = form.touched[field.name] && !isValid;
        return (
          <Form.Group as={as} md={md} controlId={controlId} className="mb-md-2">
            {label && <Form.Label>{displayLabel}</Form.Label>}
            <InputGroup>
              {inputGroupPrepend}
              <Form.Control
                {...field}
                type={type}
                disabled={disabled}
                isInvalid={isInvalid}
                feedback={form.errors[field.name]}
              />
              {inputGroupAppend}
              <Form.Control.Feedback type="invalid">
                {form.errors[field.name]}
              </Form.Control.Feedback>
            </InputGroup>
          </Form.Group>
        );
      }}
    </Field>
  );
};

export default FormInput;

================
File: Form/FormRadioGroup.tsx
================
import { Field } from "formik";
import React from "react";
import { Form, InputGroup } from "react-bootstrap";
import ToolTip from "../ToolTip";
import { IFormikFieldProps, IFormPropsWithOption } from "./interfaces";

/**
 * @author Ankur Mundra on May, 2023
 */

const FormRadioGroup: React.FC<IFormPropsWithOption> = (props) => {
  const { as, md, controlId, label, name, options, disabled, tooltip, tooltipPlacement } = props;

  const displayLabel = tooltip ? (
    <>
      {label}&nbsp;
      <ToolTip id={`${controlId}-tooltip`} info={tooltip} placement={tooltipPlacement} />
    </>
  ) : (
    label
  );

  return (
    <Field name={name}>
      {({ field, form }: IFormikFieldProps) => (
        <Form.Group as={as} md={md} controlId={controlId} className="mb-md-2">
          {label && <Form.Label>{displayLabel}</Form.Label>}
          <InputGroup>
            {options.map((option) => (
              <Form.Check
                {...field}
                key={option.value}
                type="radio"
                disabled={disabled}
                label={option.label}
                value={option.value}
                checked={field.value === option.value}
                onChange={() => form.setFieldValue(name, option.value)}
              />
            ))}
          </InputGroup>
        </Form.Group>
      )}
    </Field>
  );
};

export default FormRadioGroup;

================
File: Form/FormRange.tsx
================
import { Field } from "formik";
import React from "react";
import { Form, InputGroup } from "react-bootstrap";
import ToolTip from "../ToolTip";
import { IFormikFieldProps, IFormProps } from "./interfaces";

/**
 * @author Ankur Mundra on May, 2023
 */

interface IFormRangeProps extends IFormProps {
  min?: number;
  max?: number;
  step?: number;
}

const FormRange: React.FC<IFormRangeProps> = (props) => {
  const { controlId, label, name, min, max, step, as, md, disabled, tooltip, tooltipPlacement } =
    props;

  const displayLabel = tooltip ? (
    <>
      {label}&nbsp;
      <ToolTip id={`${controlId}-tooltip`} info={tooltip} placement={tooltipPlacement} />
    </>
  ) : (
    label
  );

  return (
    <Field name={name}>
      {({ field, form }: IFormikFieldProps) => (
        <Form.Group as={as} md={md} controlId={controlId} className="mb-md-2">
          {label && (
            <Form.Label>
              {displayLabel}: {field.value}{" "}
            </Form.Label>
          )}
          <InputGroup>
            <Form.Control
              {...field}
              type="range"
              min={min}
              max={max}
              step={step}
              disabled={disabled}
              isInvalid={form.touched[field.name] && form.errors[field.name]}
            />
            <Form.Control.Feedback type="invalid">{form.errors[field.name]}</Form.Control.Feedback>
          </InputGroup>
        </Form.Group>
      )}
    </Field>
  );
};

FormRange.defaultProps = {
  min: 0,
  max: 100,
  step: 1,
};

export default FormRange;

================
File: Form/FormSelect.tsx
================
import { Field } from "formik";
import React from "react";
import { Form, InputGroup } from "react-bootstrap";
import ToolTip from "../ToolTip";
import { IFormikFieldProps, IFormPropsWithOption } from "./interfaces";

/**
 * @author Ankur Mundra on May, 2023
 */

const FormSelect: React.FC<IFormPropsWithOption> = (props) => {
  const {
    as,
    md,
    name,
    label,
    type,
    controlId,
    options,
    tooltip,
    tooltipPlacement,
    disabled,
    inputGroupPrepend,
  } = props;

  const displayLabel = tooltip ? (
    <>
      {label}&nbsp;
      <ToolTip id={`${controlId}-tooltip`} info={tooltip} placement={tooltipPlacement} />
    </>
  ) : (
    label
  );

  return (
    <Field name={name}>
      {({ field, form }: IFormikFieldProps) => {
        const isValid = !form.errors[field.name];
        const isInvalid = form.touched[field.name] && !isValid;
        return (
          <Form.Group as={as} md={md} controlId={controlId} className="mb-md-2">
            {label && <Form.Label>{displayLabel}</Form.Label>}
            <InputGroup>
              {inputGroupPrepend}
              <Form.Select
                {...field}
                type={type}
                disabled={disabled}
                isInvalid={isInvalid}
                feedback={form.errors[field.name]}
              >
                {options.map((option) => {
                  return (
                    <option key={option.value} value={option.value}>
                      {option.label}
                    </option>
                  );
                })}
              </Form.Select>
              <Form.Control.Feedback type="invalid">
                {form.errors[field.name]}
              </Form.Control.Feedback>
            </InputGroup>
          </Form.Group>
        );
      }}
    </Field>
  );
};

FormSelect.defaultProps = {
  type: "select",
  inputGroupPrepend: null,
};

export default FormSelect;

================
File: Form/interfaces.ts
================
import { ElementType, ReactNode } from "react";

/**
 * @author Ankur Mundra on May, 2023
 */
export interface IFormProps {
  name: string;
  label?: string;
  type?: string;
  controlId: string;
  placeholder?: string;
  as?: ElementType;
  md?: number | string;
  disabled?: boolean;
  tooltip?: string;
  tooltipPlacement?: "top" | "right" | "bottom" | "left";
  inputGroupPrepend?: ReactNode;
  inputGroupAppend?: ReactNode;
}

export interface IFormOption {
  label: string;
  value: string | number;
}

export interface IFormPropsWithOption extends IFormProps {
  options: IFormOption[];
}

export interface IFormikFieldProps {
  field: any;
  form: any;
}

================
File: Table/ColumnFilter.tsx
================
import { Column } from "@tanstack/react-table";
import React, { useCallback } from "react";
import DebouncedInput from "./DebouncedInput";

/**
 * @author Ankur Mundra on May, 2023
 */

interface FilterProps {
  column: Column<any>;
}

const ColumnFilter: React.FC<FilterProps> = ({ column }) => {
  const [filterValue, setFilterValue] = [column.getFilterValue, column.setFilterValue];
  const searchHandler = useCallback(
    (value: string | number) => setFilterValue(value),
    [setFilterValue]
  );

  return (
    <DebouncedInput
      className="w-75"
      onChange={searchHandler}
      value={filterValue() ?? ""}
      placeholder="Search"
    />
  );
};

export default ColumnFilter;

================
File: Table/DebouncedInput.tsx
================
import React, { useEffect, useState } from "react";
import Input from "../Input";

/**
 * @author Ankur Mundra on May, 2023
 */

interface InputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, "onChange"> {
  debounce?: number;
  value: any;
  className?: string;
  label?: string;
  onChange: (value: any) => void;
}

const DebouncedInput: React.FC<InputProps> = ({
  onChange,
  debounce = 500,
  value: initialValue,
  className = "",
  label = "",
  ...otherProps
}) => {
  const [value, setValue] = useState<string | number>(initialValue);
  useEffect(() => setValue(initialValue), [initialValue]);
  useEffect(() => {
    const timeout = setTimeout(() => onChange(value), debounce);
    return () => clearTimeout(timeout);
  }, [debounce, onChange, value]);

  return (
    <Input
      id={`table_filter_${Math.round(Math.random())}`}
      className={className}
      label={label}
      input={{
        ...otherProps,
        value: value,
        onChange: (e: React.ChangeEvent<HTMLInputElement>) => setValue(e.target.value),
      }}
    />
  );
};

export default DebouncedInput;

================
File: Table/GlobalFilter.tsx
================
import React, { useCallback } from "react";
import DebouncedInput from "./DebouncedInput";

/**
 * @author Ankur Mundra on May, 2023
 */

interface FilterProps {
  filterValue: string | number;
  setFilterValue: (value: string | number) => void;
}

const GlobalFilter: React.FC<FilterProps> = ({ filterValue, setFilterValue }) => {
  const searchHandler = useCallback(
    (value: string | number) => setFilterValue(value),
    [setFilterValue]
  );

  return (
    <DebouncedInput
      onChange={searchHandler}
      value={filterValue ?? ""}
      className="w-75"
      label="Search"
      placeholder="Search all columns"
    />
  );
};

export default GlobalFilter;

================
File: Table/Pagination.tsx
================
import { TableState } from "@tanstack/react-table";
import React from "react";
import { Col, Pagination as BPagination, Row } from "react-bootstrap";
import Input from "../Input";
import Select from "../Select";

/**
 * @author Ankur Mundra on May, 2023
 */

interface PaginationProps {
  nextPage: () => void;
  previousPage: () => void;
  canNextPage: () => boolean;
  canPreviousPage: () => boolean;
  setPageIndex: (pageIndex: number) => void;
  setPageSize: (pageSize: number) => void;
  getPageCount: () => number;
  getState: () => TableState;
}

const Pagination: React.FC<PaginationProps> = (props) => {
  const {
    nextPage,
    previousPage,
    canNextPage,
    canPreviousPage,
    setPageIndex,
    setPageSize,
    getPageCount,
    getState,
  } = props;
  return (
    <Row className="justify-content-center">
      <Col xs="auto">
        <BPagination>
          <BPagination.First onClick={() => setPageIndex(0)} disabled={!canPreviousPage()} />
          <BPagination.Prev onClick={() => previousPage()} disabled={!canPreviousPage()} />
          <BPagination.Next onClick={() => nextPage()} disabled={!canNextPage()} />
          <BPagination.Last
            onClick={() => setPageIndex(getPageCount() - 1)}
            disabled={!canNextPage()}
          />
        </BPagination>
      </Col>
      {/*<Col xs="auto">*/}
      {/*  {`Page ${getState().pagination.pageIndex + 1} of ${getPageCount()}`}*/}
      {/*</Col>*/}
      <Col xs="auto">
        <Input
          id="columnFilter"
          label="Go to page"
          input={{
            type: "number",
            min: "1",
            max: getPageCount(),
            defaultValue: getState().pagination.pageIndex + 1,
            onChange: (e: React.ChangeEvent<HTMLInputElement>) => {
              const page = e.target.value ? Number(e.target.value) - 1 : 0;
              setPageIndex(page);
            },
          }}
        />
      </Col>
      <Col xs="auto">
        <Select
          id="pageSize"
          options={[
            { label: "Show 10", value: "10" },
            { label: "Show 25", value: "25" },
            { label: "Show 50", value: "50" },
          ]}
          input={{
            value: getState().pagination.pageSize,
            onChange: (e: React.ChangeEvent<HTMLSelectElement>) =>
              setPageSize(Number(e.target.value)),
          }}
        />
      </Col>
    </Row>
  );
};

export default Pagination;

================
File: Table/RowSelectCheckBox.tsx
================
import React, { HTMLProps, useEffect, useRef } from "react";

/**
 * @author Ankur Mundra on May, 2023
 */

interface CheckboxProps extends HTMLProps<HTMLInputElement> {
  indeterminate?: boolean;
}

const RowSelectCheckBox: React.FC<CheckboxProps> = ({ indeterminate, ...otherProps }) => {
  // null! is a hack to avoid having to make a conditional check within useEffect().
  const ref = useRef<HTMLInputElement>(null!);

  useEffect(() => {
    if (typeof indeterminate === "boolean") {
      ref.current.indeterminate = !otherProps.checked && indeterminate;
    }
  }, [ref, indeterminate, otherProps.checked]);

  return <input ref={ref} type="checkbox" {...otherProps} />;
};

export default RowSelectCheckBox;

================
File: Table/Table.tsx
================
import {
  ColumnDef,
  ColumnFiltersState,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  SortingState,
  useReactTable,
} from "@tanstack/react-table";
import React, { useEffect, useMemo, useRef, useState } from "react";
import { Col, Container, Row, Table as BTable } from "react-bootstrap";
import ColumnFilter from "./ColumnFilter";
import GlobalFilter from "./GlobalFilter";
import Pagination from "./Pagination";
import RowSelectCheckBox from "./RowSelectCheckBox";
import { FaSearch } from "react-icons/fa";

/**
 * @author Ankur Mundra on May, 2023
 */

interface TableProps {
  data: Record<string, any>[];
  columns: ColumnDef<any, any>[];
  showGlobalFilter?: boolean;
  showColumnFilter?: boolean;
  showPagination?: boolean;
  tableSize?: { span: number; offset: number };
  columnVisibility?: Record<string, boolean>;
  onSelectionChange?: (selectedData: Record<any, any>[]) => void;
}

const Table: React.FC<TableProps> = ({
  data: initialData,
  columns,
  showGlobalFilter = false,
  showColumnFilter = true,
  showPagination = true,
  onSelectionChange,
  columnVisibility = {},
  tableSize = { span: 12, offset: 0 },
}) => {
  const colsPlusSelectable = useMemo(() => {
    const selectableColumn: any = {
      id: "select",
      header: ({ table }: any) => {
        return (
          <RowSelectCheckBox
            {...{
              checked: table.getIsAllRowsSelected(),
              indeterminate: table.getIsSomeRowsSelected(),
              onChange: table.getToggleAllRowsSelectedHandler(),
            }}
          />
        );
      },
      cell: ({ row }: any) => {
        return (
          <RowSelectCheckBox
            {...{
              checked: row.getIsSelected(),
              disabled: !row.getCanSelect(),
              indeterminate: row.getIsSomeSelected(),
              onChange: row.getToggleSelectedHandler(),
            }}
          />
        );
      },
      enableSorting: false,
      enableFilter: false,
    };
    return [selectableColumn, ...columns];
  }, [columns]);

  const [rowSelection, setRowSelection] = useState({});
  const [sorting, setSorting] = useState<SortingState>([]);
  const [globalFilter, setGlobalFilter] = useState<string | number>("");
  const [columnFilters, setColumnFilters] = useState<ColumnFiltersState>([]);
  const [columnVisibilityState, setColumnVisibilityState] = useState(columnVisibility);
  const [isGlobalFilterVisible, setIsGlobalFilterVisible] = useState(showGlobalFilter); // State for global filter visibility

  const selectable = typeof onSelectionChange === "function";
  const onSelectionChangeRef = useRef<any>(onSelectionChange);

  const table = useReactTable({
    data: initialData,
    columns: selectable ? colsPlusSelectable : columns,
    state: {
      sorting,
      globalFilter,
      columnFilters,
      rowSelection,
      columnVisibility: columnVisibilityState,
    },
    onSortingChange: setSorting,
    onRowSelectionChange: setRowSelection,
    onGlobalFilterChange: setGlobalFilter,
    onColumnFiltersChange: setColumnFilters,
    onColumnVisibilityChange: setColumnVisibilityState,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
  });

  const {
    getState,
    getHeaderGroups,
    getRowModel,
    getCanNextPage,
    getCanPreviousPage,
    previousPage,
    nextPage,
    setPageIndex,
    setPageSize,
    getPageCount,
  } = table;

  // Used to return early from useEffect() on mount.
  const firstRenderRef = useRef(true);
  // This useEffect() watches flatRows such that on change it
  // calls the onSelectionChange() prop. Technically, it calls
  // the onSelectionChangeRef.current function if it exists.

  const flatRows = table.getSelectedRowModel().flatRows;

  useEffect(() => {
    if (firstRenderRef.current) {
      firstRenderRef.current = false;
      return;
    }

    if (typeof onSelectionChangeRef.current !== "function") {
      return;
    }
    const selectedData = flatRows.map((flatRow) => flatRow.original);
    const handleSelectionChange = onSelectionChangeRef.current;
    handleSelectionChange?.(selectedData);
  }, [flatRows]);

  const toggleGlobalFilter = () => {
    setIsGlobalFilterVisible(!isGlobalFilterVisible);
  };

  return (
    <>
      <Container>
        <Row className="mb-md-2">
          <Col md={{ span: 12 }}>
            {isGlobalFilterVisible && (
              <GlobalFilter filterValue={globalFilter} setFilterValue={setGlobalFilter} />
            )}
          </Col>
          <span style={{ marginLeft: "5px" }} onClick={toggleGlobalFilter}>
            <FaSearch style={{ cursor: "pointer" }} />
            {isGlobalFilterVisible ? " Hide" : " Show"}
          </span>{" "}
        </Row>
      </Container>
      <Container>
        <Row>
          <Col md={tableSize}>
            <BTable striped hover responsive size="sm">
              <thead className="table-secondary">
                {getHeaderGroups().map((headerGroup) => (
                  <tr key={headerGroup.id}>
                    {headerGroup.headers.map((header) => {
                      return (
                        <th key={header.id} colSpan={header.colSpan}>
                          {header.isPlaceholder ? null : (
                            <>
                              <div
                                {...{
                                  className: header.column.getCanSort()
                                    ? "cursor-pointer select-none"
                                    : "",
                                  onClick: header.column.getToggleSortingHandler(),
                                }}
                              >
                                {flexRender(header.column.columnDef.header, header.getContext())}
                                {{
                                  asc: " ðŸ”¼",
                                  desc: " ðŸ”½",
                                }[header.column.getIsSorted() as string] ?? null}
                              </div>
                              {showColumnFilter && header.column.getCanFilter() ? (
                                <ColumnFilter column={header.column} />
                              ) : null}
                            </>
                          )}
                        </th>
                      );
                    })}
                  </tr>
                ))}
              </thead>
              <tbody>
                {getRowModel().rows.map((row) => {
                  return (
                    <tr key={row.id}>
                      {row.getVisibleCells().map((cell) => {
                        return (
                          <td key={cell.id}>
                            {flexRender(cell.column.columnDef.cell, cell.getContext())}
                          </td>
                        );
                      })}
                    </tr>
                  );
                })}
              </tbody>
            </BTable>
            {showPagination && (
              <Pagination
                nextPage={nextPage}
                previousPage={previousPage}
                canNextPage={getCanNextPage}
                canPreviousPage={getCanPreviousPage}
                setPageIndex={setPageIndex}
                setPageSize={setPageSize}
                getPageCount={getPageCount}
                getState={getState}
              />
            )}
          </Col>
        </Row>
      </Container>
    </>
  );
};

export default Table;

================
File: Alert.tsx
================
import React from "react";
import Alert from "react-bootstrap/Alert";
import { useDispatch } from "react-redux";
import { alertActions } from "store/slices/alertSlice";

/**
 * @author Ankur Mundra on May, 2023
 */

interface IAlertProps {
  variant: string;
  title?: string;
  message: string;
}

const AlertMessage: React.FC<IAlertProps> = (props) => {
  const dispatch = useDispatch();
  const hideAlertHandler = () => dispatch(alertActions.hideAlert());

  return (
    <Alert variant={props.variant} onClose={hideAlertHandler} dismissible>
      {props.title && <Alert.Heading>{props.title}</Alert.Heading>}
      <p>{props.message}</p>
    </Alert>
  );
};

export default AlertMessage;

================
File: Input.tsx
================
import React from "react";
import { FormControl, InputGroup } from "react-bootstrap";
import ToolTip from "./ToolTip";

/**
 * @author Ankur Mundra on May, 2023
 */

interface InputProps {
  id: string;
  label?: string;
  tooltip?: string;
  input?: any;
  className?: string;
}

const Input: React.ForwardRefExoticComponent<InputProps> = React.forwardRef((props, ref) => {
  const displayLabel = props.tooltip ? (
    <>
      {props.label + " "}
      <ToolTip id={`${props.id}-tooltip`} info={props.tooltip} />
    </>
  ) : (
    props.label
  );

  return (
    <InputGroup className={props.className}>
      <InputGroup.Text id={props.id}>{displayLabel}</InputGroup.Text>
      <FormControl aria-label={props.label} ref={ref} {...props.input} />
    </InputGroup>
  );
});

export default Input;

================
File: Select.tsx
================
import React from "react";
import { Form, InputGroup } from "react-bootstrap";
import ToolTip from "./ToolTip";

/**
 * @author Ankur Mundra on May, 2023
 */

interface SelectProps {
  id: string;
  label?: string;
  tooltip?: string;
  input: any;
  options: { value: string; label: string }[];
  className?: string;
}

const Select: React.ForwardRefExoticComponent<SelectProps> = React.forwardRef((props, ref) => {
  const { className, id, label, input, options, tooltip } = props;

  const displayLabel = tooltip ? (
    <>
      {label + " "}
      <ToolTip id={`${id}-tooltip`} info={tooltip} />
    </>
  ) : (
    label
  );

  return (
    <InputGroup className={className}>
      <InputGroup.Text id={id}>{displayLabel}</InputGroup.Text>
      <Form.Select aria-label={label} ref={ref} {...input}>
        {options.map((option, index) => (
          <option key={index} value={option.value}>
            {option.label}
          </option>
        ))}
      </Form.Select>
    </InputGroup>
  );
});

export default Select;

================
File: ToolTip.tsx
================
import React from "react";
import {OverlayTrigger, Tooltip} from "react-bootstrap";
import {FcInfo} from "react-icons/fc";

/**
 * @author Ankur Mundra on May, 2023
 */

interface ToolTipProps {
  id: string;
  info: string;
  placement?: "top" | "right" | "bottom" | "left";
}

const ToolTip: React.FC<ToolTipProps> = (props) => {
  const tooltip = <Tooltip id={`tooltip-${props.id}`}>{props.info}</Tooltip>;

  return (
    <OverlayTrigger
      placement={props.placement || "right"}
      delay={{ show: 150, hide: 300 }}
      overlay={tooltip}
    >
      <span>
        <FcInfo />
      </span>
    </OverlayTrigger>
  );
};

export default ToolTip;
